# Ход работы

Будем брать пока книги и фильмы.
Примерный план такой:
### Main
После /start вызывается главная функция (пусть будет **main**). <br>
В **main** предусмотреть следующее:
* Если **/команда**, то выполнить соответствующую функцию. <br>
* Если текстовое сообщение, то обработать его: разбить на данные и внести в базу.

### **Примерный план команд** <br>

**/help** - должна выдавать список команд, описание работы бота и т.д. <br>
**/rndfilm**, **/rndbook** - вывести случайную запись из БД. При этом должна быть возможность сгененировать что-то другое (исключить возможность повторения результатов). Если были перечислены все варианты или в базе вообще нет записей, то предусмотреть соответствующие сообщения. <br>
**/viewall** - посмотреть все, что было внесено в БД бота. Книги и фильмы можно в сообщении разделить друг от друга. <br>
**/remove** - удалить что-то, по названию либо по номеру в соответствующей категории. <br>
**/return** - прерывает выполнение функций, вызванных через другие команды, т.е. выход <br>

### **Обработка текста** <br>

Текст должен идти в формате <категория>[пробел]<название>, либо в обратном порядке. Для начала можно остановиться на одном. <br>
Необходимо учесть, что текст может вводиться в разных регистрах. <br> 
Например, фильм Матрица, Фильм Матрица, фильм матрица - эквивалетны. <br>
В общем, парсер сообщений должен разделять, где категория, а где название, и название желательно преобразовывать в один формат, чтобы не было такого, что в списке какие-то названия в нижнем регистре, а какие-то с заглавной буквы.
В случае, если распознание не произошло, то функция парсера должна вернуть соответствующее сообщение, при этом пользователь может ввести инфу заново, либо выйти.

### **Работа с БД** <br>

Тут что-то будет, когда я изучу как работает sqlite <br>
Думаю, можно для начала работать с массивами, а потом просто переписать функции под запросы <br>



### **Обработка текста** <br>

В общем, структура кода должна быть примерно такой: <br>

**main()** { <br>
основной код для бота, с прокси, токенами, связкой команд и функций и т.д <br>
} <br>

**help()** { <br>
вывод большого справочного сообщения <br>
} <br>

**getRandomBook() / getRandomFilm() {** <br>
тут будет обращение к бд, подсчет количества записей, их индексы нужно будет перекинуть в массив или типа того, затем оттуда получать случайный индекс и выводить элемент по нему. Затем надо вызвать еще одну функцию, пусть она будет называться confirmChoice(). При ее вызове бот должен спросить пользователя, удовлетворяет ли его случайно выбранная запись. В зависимости от ответа пользователя функция должна вернуть 1 или 0, и пока она не вернет 1 или пользователь не введет команду /return, функция getRandom должна вызываться бесконечно <br>
}  <br>

**viewAll(), remove()** { <br>
Что-то типа SELECT * FROM ... , REMOVE * FROM ..., только на Питоне
} <br>

**return()** { <br>
Тут я не знаю, как можно это сделать, но в моем представлении это скорее всего не функция, а вызов директивы break при выполнении условия "дана команда /return" <br>
}
